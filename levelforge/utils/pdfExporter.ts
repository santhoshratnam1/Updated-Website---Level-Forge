import * as jspdf from 'jspdf';
import type { Block, GeneratedAsset, ChecklistState } from '../types/portfolio';
import { checklistData } from '../data/checklistItems';

// Image caching to avoid re-loading images multiple times
const imageCache = new Map<string, HTMLImageElement>();

const loadImage = (url: string): Promise<HTMLImageElement> => {
  if (imageCache.has(url)) {
    return Promise.resolve(imageCache.get(url)!);
  }
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      imageCache.set(url, img);
      resolve(img);
    };
    img.onerror = reject;
    img.src = url;
  });
};

// A debounced function to avoid generating PDFs multiple times on rapid clicks
function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {
    let timeout: number | undefined;
    return function(...args: Parameters<T>) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = window.setTimeout(later, wait);
    };
}

const exportToPdfInternal = async (
    blocks: Block[], 
    images: GeneratedAsset[], 
    levelName: string,
    checklistState: ChecklistState
): Promise<void> => {
    const doc = new jspdf.jsPDF({
        orientation: 'p',
        unit: 'px',
        format: 'a4',
    });

    const pageHeight = doc.internal.pageSize.getHeight();
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 30;
    const maxLineWidth = pageWidth - margin * 2;
    let cursorY = margin;

    const addPageIfNeeded = (spaceNeeded: number) => {
        if (cursorY + spaceNeeded > pageHeight - margin) {
            doc.addPage();
            cursorY = margin;
            addHeaderFooter();
        }
    };

    const addHeaderFooter = () => {
        // Footer
        doc.setFontSize(8);
        doc.setTextColor(150);
        const pageCount = doc.internal.pages.length;
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            doc.text('Generated by LevelForge', margin, pageHeight - 15);
            doc.text(`Page ${i}`, pageWidth - margin, pageHeight - 15, { align: 'right' });
        }
    };
    
    // Render Portfolio Blocks
    for (const block of blocks) {
        switch (block.type) {
            case 'heading_1':
                addPageIfNeeded(40);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(28);
                doc.setTextColor(0, 105, 133);
                doc.text(block.content.text, pageWidth / 2, cursorY, { align: 'center' });
                cursorY += 40;
                break;

            case 'heading_2':
                addPageIfNeeded(30);
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(20);
                doc.setTextColor(20, 20, 20);
                doc.text(block.content.text, margin, cursorY);
                cursorY += 30;
                break;
                
            case 'heading_3':
                 addPageIfNeeded(20);
                 doc.setFont('helvetica', 'bold');
                 doc.setFontSize(14);
                 doc.setTextColor(50, 50, 50);
                 doc.text(block.content.text, margin, cursorY);
                 cursorY += 20;
                 break;

            case 'paragraph':
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                doc.setTextColor(80, 80, 80);
                const lines = doc.splitTextToSize(block.content.text || '', maxLineWidth);
                addPageIfNeeded(lines.length * 15 + 10);
                doc.text(lines, margin, cursorY);
                cursorY += lines.length * 15 + 5;
                break;

            case 'callout':
                addPageIfNeeded(40);
                doc.setFillColor(230, 247, 255); // Light cyan background
                doc.roundedRect(margin - 5, cursorY - 15, maxLineWidth + 10, 10, 3, 3, 'F');
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(11);
                doc.setTextColor(0, 105, 133);
                doc.text(block.content.title, margin, cursorY - 5);
                
                const calloutLines = doc.splitTextToSize(block.content.text || '', maxLineWidth);
                addPageIfNeeded(calloutLines.length * 15 + 25);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(80, 80, 80);
                doc.text(calloutLines, margin, cursorY + 15);
                cursorY += calloutLines.length * 15 + 25;
                break;

            case 'columns':
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(10);
                doc.setTextColor(80, 80, 80);
                const colWidth = maxLineWidth / 2 - 5;
                const leftLines = doc.splitTextToSize(block.content.left || '', colWidth);
                const rightLines = doc.splitTextToSize(block.content.right || '', colWidth);
                const requiredHeight = Math.max(leftLines.length, rightLines.length) * 12 + 10;
                addPageIfNeeded(requiredHeight);
                doc.text(leftLines, margin, cursorY);
                doc.text(rightLines, margin + colWidth + 10, cursorY);
                cursorY += requiredHeight;
                break;

            case 'divider':
                addPageIfNeeded(20);
                doc.setDrawColor(220, 220, 220);
                doc.line(margin, cursorY, pageWidth - margin, cursorY);
                cursorY += 20;
                break;
        }
    }

    // Add Checklist Page
    doc.addPage();
    cursorY = margin;
    addHeaderFooter();
    
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(24);
    doc.setTextColor(20, 20, 20);
    doc.text('Design Checklist', pageWidth / 2, cursorY, { align: 'center' });
    cursorY += 30;

    const allItems = checklistData.flatMap(c => c.items);
    const checkedCount = Object.values(checklistState).filter(Boolean).length;
    const completionPercentage = Math.round((checkedCount / allItems.length) * 100);

    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`Completion: ${completionPercentage}%`, margin, cursorY);
    cursorY += 20;
    
    for (const category of checklistData) {
        addPageIfNeeded(30 + category.items.length * 15);
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(14);
        doc.setTextColor(50, 50, 50);
        doc.text(category.title, margin, cursorY);
        cursorY += 18;

        doc.setFont('helvetica', 'normal');
        doc.setFontSize(10);
        for (const item of category.items) {
            addPageIfNeeded(15);
            const isChecked = checklistState[item.id];
            doc.setTextColor(isChecked ? 150 : 80);
            doc.text(`[${isChecked ? 'x' : ' '}] ${item.label}`, margin + 10, cursorY);
            cursorY += 15;
        }
        cursorY += 10;
    }


    // Add images on a new page
    doc.addPage();
    cursorY = margin;
    addHeaderFooter();

    doc.setFont('helvetica', 'bold');
    doc.setFontSize(24);
    doc.setTextColor(20, 20, 20);
    doc.text('Generated Visual Assets', pageWidth / 2, cursorY, { align: 'center' });
    cursorY += 30;

    // Pre-load all images in parallel
    const imagePromises = images.map(image => loadImage(image.url));
    const loadedImages = await Promise.allSettled(imagePromises);

    for (let i = 0; i < images.length; i++) {
      const result = loadedImages[i];
      const image = images[i];
      
      if (result.status === 'rejected') {
        console.error(`Could not add image ${image.title} to PDF:`, result.reason);
        addPageIfNeeded(20);
        doc.setTextColor(255, 0, 0);
        doc.text(`Error: Could not load image "${image.title}"`, margin, cursorY);
        doc.setTextColor(80, 80, 80);
        cursorY += 20;
        continue;
      }
      
      try {
        // Use the loaded image or the original url (since it's base64/url, jsPDF handles it if we confirmed it loads)
        const imgProps = doc.getImageProperties(image.url);
        const aspectRatio = imgProps.width / imgProps.height;
        const imgWidth = maxLineWidth * 0.8;
        const imgHeight = imgWidth / aspectRatio;

        addPageIfNeeded(imgHeight + 40);

        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(80, 80, 80);
        doc.text(image.title, pageWidth / 2, cursorY, { align: 'center' });
        cursorY += 15;

        doc.addImage(image.url, 'JPEG', (pageWidth - imgWidth) / 2, cursorY, imgWidth, imgHeight);
        cursorY += imgHeight + 25;
      } catch (e) {
        console.error(`Could not add image ${image.title} to PDF:`, e);
        addPageIfNeeded(20);
        doc.setTextColor(255, 0, 0);
        doc.text(`Error: Could not render image "${image.title}"`, margin, cursorY);
        doc.setTextColor(80, 80, 80);
        cursorY += 20;
      }
    }
    
    addHeaderFooter();

    const safeFilename = levelName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    doc.save(`LevelForge-${safeFilename}-Portfolio.pdf`);
};

export const exportToPdf = debounce(exportToPdfInternal, 1000);